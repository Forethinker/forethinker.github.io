var tipuesearch = {"pages":[{"title":"K Closest Points to Origin | Medium","text":"Leetcode Intuition: Calculate the distance, sort it then return the first K element Gotchas: square root not necessary Base cases: None Solution: class Solution : def kClosest ( self , points : List [ List [ int ]], K : int ) -> List [ List [ int ]]: points . sort ( key = lambda p :( p [ 0 ] ** 2 + p [ 1 ] ** 2 )) return points [: K ] # Using class Solution : def kClosest ( self , points : List [ List [ int ]], K : int ) -> List [ List [ int ]]: heap = [] for p in points : d = - ( p [ 0 ] ** 2 + p [ 1 ] ** 2 ) heapq . heappush ( heap , ( d , p )) if len ( heap ) > K : heapq . heappop ( heap ) return [ p for d , p in heap ] Complexity Analysis: O(N*log(N)) Runtime: 724 ms, faster than 52.59% of Python3 online submissions for K Closest Points to Origin. Memory Usage: 18.3 MB, less than 5.80% of Python3 online submissions for K Closest Points to Origin. Next challenges:","tags":"algorithms","url":"https://forethinker.github.io/k-closest-points-to-origin.html","loc":"https://forethinker.github.io/k-closest-points-to-origin.html"},{"title":"Remove Invalid Parentheses | Hard","text":"Leetcode Intuition: - Use DFS to recursively either remove the character or just continue. Gotchas: - The program expects empty string in the answer if there are no other matches - non-parenthesis characters is like a no-op character, that moves the iterator without doing anything. - The answer needs to be in set to avoid duplicates - left parenthesis(L) has a preferential consideration over right parenthesis(R) since R is an invariant if there is more R than L at any given position. Base case: - The resulting answer should have a matching number of parenthesis. - Iteration ends when the iteration reaches the end of the string Solution 1 (One pass, no extra memory) : class Solution : def removeInvalidParentheses ( self , s : str ) -> List [ str ] : ans = set () N = len ( s ) length = 0 def traverse ( left , right , i , stack ) : nonlocal s , ans , N , length if i == N : if stack and left == 0 and right == 0 : # 3 if len ( stack ) > length : ans = { stack } length = len ( stack ) elif len ( stack ) == length : ans.add ( stack ) else : if s [ i ] == '(' : if right == 0 : traverse ( left + 1 , right , i + 1 , stack + s [ i ]) traverse ( left , right , i + 1 , stack ) elif s [ i ] == ')' : if left > 0 : traverse ( left - 1 , right , i + 1 , stack + s [ i ]) traverse ( left , right , i + 1 , stack ) else : traverse ( left , right , i + 1 , stack + s [ i ]) traverse ( 0 , 0 , 0 , \"\" ) return ans or [ \"\" ] # 1 Solution 2 (Two Pass, calculate the invariants first) class Solution : def removeInvalidParentheses ( self , s : str ) -> List [ str ] : ans = set () N = len ( s ) left_rem , right_rem = 0 , 0 for i in range ( N ) : if s [ i ] == '(' : left_rem += 1 # Preferential treatment of L elif s [ i ] == ')' : if left_rem > 0 : left_rem -= 1 else : right_rem += 1 def dfs ( i , left , right , left_rem , right_rem , stack ) : nonlocal ans if i == N : if left_rem == 0 and right_rem == 0 : ans.add ( stack ) return else : if s [ i ] == \"(\" : if left_rem > 0 : dfs ( i + 1 , left , right , left_rem - 1 , right_rem , stack ) # Preferential treatment of L . No condition for considering it dfs ( i + 1 , left + 1 , right , left_rem , right_rem , stack + s [ i ]) elif s [ i ] == \")\" : if right_rem > 0 : dfs ( i + 1 , left , right , left_rem , right_rem - 1 , stack ) if left > right : dfs ( i + 1 , left , right + 1 , left_rem , right_rem , stack + s [ i ]) else : dfs ( i + 1 , left , right , left_rem , right_rem , stack + s [ i ]) dfs ( 0 , 0 , 0 , left_rem , right_rem , \"\" ) return ans Complexity Analysis: O(2&#94;N) since for each character we have an option of either considering or discarding it. But in the second solution, pruning is done much actively, O(2&#94;(k)) where k = '# of invariants'","tags":"algorithms","url":"https://forethinker.github.io/remove-invalid-parentheses.html","loc":"https://forethinker.github.io/remove-invalid-parentheses.html"},{"title":"Minimum Remove to Make Valid Parentheses | Medium","text":"Leetcode Intuition: Calculate the invariant (out of place) parentheses first and then remove them. Gotchas: Unlike getting all possibilities, this doesn't require recursion / search / stack or queue. Trying to solve by looping in sequence doesn't work. Right parentheses can be removed in sequence, but Left parentheses are efficiently removed in reverse. Character can be set to \"\" instead of creating a new string Base cases: None for loops. Splitting the string into a char list makes it easier to \"remove\" a character Solution: class Solution : def minRemoveToMakeValid ( self , s : str ) -> str : left_rem = 0 s = [ c for c in s ] N = len ( s ) for i in range ( N ): if s [ i ] == '(' : left_rem += 1 elif s [ i ] == ')' : if left_rem > 0 : left_rem -= 1 else : s [ i ] = '' i = N - 1 while left_rem and i > - 1 : if s [ i ] == '(' : s [ i ] = '' left_rem -= 1 i -= 1 return \"\" . join ( s ) Complexity Analysis: O(N)","tags":"algorithms","url":"https://forethinker.github.io/minimum-remove-to-make-valid-parentheses.html","loc":"https://forethinker.github.io/minimum-remove-to-make-valid-parentheses.html"},{"title":"Product of Array Except Self | Medium","text":"Leetcode Intuition: Create a left list that should be cumulative of [0:i-1] for given i Create a right list that should be cumulative of [i+1:-1] for a given i return list of left[i] * right[~i] Gotchas: Either the multiplied sum needs to be applied at the proper location AND iteration needs to exclude the last element or there is implied 1 multiplication due to the shift in the iteration Base cases: Initialize the answer as list of 1 Or initialize the left and right accumulation list with implied 1 Solution (Optimized, prealloc): class Solution ( object ): def productExceptSelf ( self , nums ): N = len ( nums ) output = [ 1 ] * N sofar = 1 for i in range ( 0 , N - 1 ): sofar *= nums [ i ] output [ i + 1 ] = sofar sofar = 1 for j in range ( N - 1 , 0 , - 1 ): sofar *= nums [ j ] output [ j - 1 ] *= sofar return output Solution (Straight forward) class Solution : def productExceptSelf ( self , nums : List [ int ]) -> List [ int ]: right = [ 1 ] right_sum = 1 for num in nums [: - len ( nums ): - 1 ]: right_sum *= num right . append ( right_sum ) left = [ 1 ] left_sum = 1 for i , num in enumerate ( nums [: - 1 ]): left_sum *= num left . append ( left_sum ) return [ l * r for l , r in zip ( left , right [:: - 1 ])] Complexity Analysis: O(N)","tags":"algorithms","url":"https://forethinker.github.io/product-of-array-except-self.html","loc":"https://forethinker.github.io/product-of-array-except-self.html"},{"title":"Valid Palindrome II","text":"https://leetcode.com/problems/valid-palindrome-ii/ Intuition: Set two iterators from the beginning and the end and make adjustments Gotchas: the deletion might be needed from the either side of the iteration. So from the point of the mismatch, two verifications are needed slicing the char character may be tricky Base cases: None Solution: class Solution : def validPalindrome ( self , s : str ) -> bool : i = 0 j = len ( s ) - 1 used = False while i <= j : if not s [ i ] == s [ j ] : return s [ i : j ] == s [ i : j ][ ::- 1 ] or s [ i + 1 :j + 1 ] == s [ i + 1 :j + 1 ][ ::- 1 ] # indexing i += 1 j -= 1 return True Complexity Analysis: O(N)","tags":"algorithms","url":"https://forethinker.github.io/valid-palindrome-ii.html","loc":"https://forethinker.github.io/valid-palindrome-ii.html"},{"title":"Verifying an Alien Dictionary | Easy","text":"Leetcode Intuition: Store the alien alphabet in a dictionary so that lookup can be in O(1) Gotchas Not all characters need to be verified, only when the characters are equal The words might not be of the same length Base case: at least two words to be given Solution: class Solution : def isAlienSorted ( self , words : List [ str ], order : str ) -> bool : order = { v : k for k , v in enumerate ( order ) } if len ( words ) < 2 : return True i = 0 j = 1 def compareWords ( w1 , w2 ): i = 0 j = 0 while i < len ( w1 ) and j < len ( w2 ): if order [ w1 [ i ]] < order [ w2 [ j ]]: return True elif order [ w1 [ i ]] > order [ w2 [ j ]]: return False else : i += 1 j += 1 if len ( w1 ) < len ( w2 ): return True else : return False while j < len ( words ): if not compareWords ( words [ i ], words [ j ]): return False i += 1 j += 1 return True Complexity Analysis: O(N) where N is the length of all characters in the word list","tags":"algorithms","url":"https://forethinker.github.io/verifying-an-alien-dictionary.html","loc":"https://forethinker.github.io/verifying-an-alien-dictionary.html"}]};